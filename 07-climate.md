---
layout: lesson
root: ../..
---

## Working With Climate Data


<div class="">
<p>To pull everything together, we'll analyze some climate data to find out whether some parts of the world are getting hotter and drier faster than others.</p>
</div>


<div class="objectives">
<h4 id="objectives">Objectives</h4>
<ul>
<li>FIXME</li>
</ul>
</div>

### Step 1: Finding the Data


<div class="">
<p>A growing number of organizations make data sets available on the web in a style called <a href="../../gloss.html#rest">REST</a>, which stands for REpresentational State Transfer. The details (and ideology) aren't important to us; what matters is that when REST is used, every data set is identified by a URL.</p>
<p>For this example, we'll use data generated by 15 global circulation models that is provided through the World Bank's <a href="http://data.worldbank.org/developers/climate-data-api">Climate Data API</a>. According to the API's home page, the data sets containing yearly averages for various values are identified by URLs of the form:</p>
<pre>
http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/<em><strong>var</strong></em>/year/<em><strong>iso3</strong></em>.<em><strong>ext</strong></em>
</pre>

<p>where:</p>
<ul>
<li><em><strong>var</strong></em> is either <code>pr</code> (for precipitation) or <code>tas</code> (for &quot;temperature at surface&quot;);</li>
<li><em><strong>iso3</strong></em> is the International Standards Organization (ISO) <a href="http://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">3-letter code for a specific country</a>, such as &quot;CAN&quot; for Canada or &quot;BRA&quot; for Brazil; and</li>
<li><em><strong>ext</strong></em> (short for &quot;extension&quot;) specifies the format we want the data in.</li>
</ul>
<p>There are several choices for format, such as XML and JSON, but the simplest is <a href="../../gloss.html#csv">comma-separated values</a> (CSV), in which each record is a row, and the values in each row are separated by commas.</p>
<p>For example, if we want the average annual temperature in Canada as a CSV file, the URL is:</p>
<pre>
http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv
</pre>

<p>If we paste that URL into a browser, it displays:</p>
<pre><code>year,data
1901,-7.67241907119751
1902,-7.862711429595947
1903,-7.910782814025879
...
2007,-6.819293975830078
2008,-7.2008957862854
2009,-6.997011661529541</code></pre>
<blockquote>
<h4>Behind the Scenes</h4>
<p>This particular data set probably <em>isn't</em> stored in a file on the World Bank's server. Instead, that server is almost certainly:</p>
<ol style="list-style-type: decimal">
<li>receiving our URL,</li>
<li>breaking it into pieces,</li>
<li>extracting the three key fields (the variable, the country code, and the desired format),</li>
<li>fetching the desired data from a database,</li>
<li>formatting the data as CSV, and</li>
<li>sending that to our browser.</li>
</ol>
<p>The two strengths of the REST model are that we don't need to know, and that the World Bank could switch from one to the other (or to something else entirely) As long as they are consistent about how URLs map to data sets and vice versa, they can change how they do things without affecting us.</p>
</blockquote>
</div>


<div class="challenges">
<h4 id="challenges">Challenges</h4>
<ol style="list-style-type: decimal">
<li>FIXME</li>
</ol>
</div>

### Step 2: Getting the Data


<div>
<p>If we only wanted to look at data for two or three countries, we could just download those files one by one. But we want to compare data for many different pairs of countries, which means we should write a program.</p>
<p>Python has a library called <code>urllib2</code> for working with URLs. It can be clumsy to use, though, so many people (including us) prefer a third-party library called <a href="http://docs.python-requests.org/en/latest/">Requests</a>. To install it, run the command:</p>
</div>


<div class="in">
<pre>!pip install requests</pre>
</div>

<div class="out">
<pre>Requirement already satisfied (use --upgrade to upgrade): requests in /Users/gwilson/anaconda/lib/python2.7/site-packages
Cleaning up...
</pre>
</div>


<div>
<p>(We get this message because we already have it installed; if you don't, you'll see a different message.) We can now get the data we want like this:</p>
</div>


<div class="in">
<pre>import requests
url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv&#39;
response = requests.get(url)
if response.status_code != 200:
    print &#39;Failed to get data:&#39;, response.status_code
else:
    print &#39;First 100 characters of data is&#39;
    print response.text[:100]</pre>
</div>

<div class="out">
<pre>First 100 characters of data is
year,data
1901,-7.67241907119751
1902,-7.862711429595947
1903,-7.910782814025879
1904,-8.15572929382
</pre>
</div>


<div>
<p>The first line imports the <code>requests</code> library. The second defines the URL for the data we want; we could just pass this URL as an argument to the <code>requests.get</code> call on the third line, but assigning it to a variable makes it easier to find.</p>
<p><code>requests.get</code> actually gets our data. More specifically, it:</p>
<ol style="list-style-type: decimal">
<li>creates a connection to the <code>climatedataapi.worldbank.org</code> server;</li>
<li>sends it the URL <code>/climateweb/rest/v1/country/cru/tas/year/CAN.csv</code>;</li>
<li>creates an object in memory on our computer to hold the response;</li>
<li>assigns a number to the object's <code>status_code</code> member variable to tell us whether the request succeeded or not; and</li>
<li>assigns the data sent back by the web server to the object's <code>text</code> member variable.</li>
</ol>
<p>The server can return many different <a href="../../gloss.html#http-status-code">status codes</a>; the most common are:</p>
<table>
  <tr><td>
200
</td><td>
OK
</td><td>
The request has succeeded
</td></tr>
  <tr><td>
204
</td><td>
No Content
</td><td>
The server has completed the request, but doesn't need to return any data
</td></tr>
  <tr><td>
400
</td><td>
Bad Request
</td><td>
The request is badly formatted
</td></tr>
  <tr><td>
401
</td><td>
Unauthorized
</td><td>
The request requires authentication
</td></tr>
  <tr><td>
404
</td><td>
Not Found
</td><td>
The requested resource could not be found
</td></tr>
  <tr><td>
408
</td><td>
Timeout
</td><td>
The server gave up waiting for the client
</td></tr>
  <tr><td>
418
</td><td>
I'm a teapot
</td><td>
No, really
</td></tr>
  <tr><td>
500
</td><td>
Internal Server Error
</td><td>
An error occurred in the server
</td></tr>
</table>

<p>Of these, 200 is the only one we really care about: if we get anything else, the response probably doesn't contain actual data (though it might contain an error message).</p>
<blockquote>
<h4>Some People Don't Follow the Rules</h4>
<p>Unfortunately, there are still a few sites out there that don't return a meaningful status code. Instead, they return 200 for <em>everything</em>, then put an error message (if appropriate) in the text of the response. This works when the result is being displayed to a human being, but fails miserably when the &quot;reader&quot; is a program that can't actually read.</p>
</blockquote>
</div>


<div class="challenges">
<h4 id="challenges">Challenges</h4>
<ol style="list-style-type: decimal">
<li>FIXME</li>
</ol>
</div>

### Step 3: Parsing the Data


<div>
<p>Our little program gets the data we want, but returns it as one long character string rather than as a list of numbers. There are two ways we could convert the former to the latter:</p>
<ol style="list-style-type: decimal">
<li>Write a function to split that string on newline characters to create lines, then split the lines on commas and convert the second part of each to a number.</li>
<li>Use a couple of Python libraries to do this for us.</li>
</ol>
<p>Most experienced programmers would say that the second approach is better, but that's only true if we know that libraries exist to do the things we want. In fact, even that isn't true: &quot;use the standard libraries&quot; is only more effective in practice if we know enough about those libraries to think about our problem in terms of what they can do.</p>
<p>Let's give both methods a try. Here's a small program to test the first approach:</p>
</div>


<div class="in">
<pre>input_data = &#39;&#39;&#39;1901,12.3
1902,45.6
1903,78.9&#39;&#39;&#39;

as_lines = input_data.split(&#39;\n&#39;)
print &#39;input data as lines:&#39;
print as_lines

for line in as_lines:
    fields = line.split(&#39;,&#39;)
    year = int(fields[0])
    value = float(fields[1])
    print year, &#39;:&#39;, value</pre>
</div>

<div class="out">
<pre>input data as lines:
[&#39;1901,12.3&#39;, &#39;1902,45.6&#39;, &#39;1903,78.9&#39;]
1901 : 12.3
1902 : 45.6
1903 : 78.9
</pre>
</div>


<div>
<p>We start by defining a string in our program to use as input data so that we can easily check the correctness of our output. The first three lines of code turn this one multi-line string into a list of strings by splitting on the newline characters (which are written <code>\n</code> in our program). The <code>for</code> loop then extracts the year and value from each line by splitting the line on the comma and converting the digits to numbers.</p>
</div>


<div>
<p>Now let's have a look at how we could do this using a couple of standard Python libraries. The first, called <code>cStringIO</code>, lets Python treat a string as if it was an input file:</p>
</div>


<div class="in">
<pre>import cStringIO

data = &#39;&#39;&#39;first
second
third&#39;&#39;&#39;

reader = cStringIO.StringIO(data)
for line in reader:
    print line</pre>
</div>

<div class="out">
<pre>first

second

third
</pre>
</div>


<div>
<p>The <code>cStringIO.StringIO</code> object that we assign to <code>reader</code> is an object that behaves like a file, but reads characters from a string instead of from something on our hard drive. As we'll see in the exercises, we can also write to a <code>StringIO</code> object, which is very useful when we're testing programs.</p>
<blockquote>
<h3>Why the 'c'?</h3>
<p>The 'c' at the start of <code>cStringIO</code>'s name comes from the fact that it is a rewrite in C of an older and slower library called <code>StringIO</code>.</p>
</blockquote>
<p>The second library we'll use is called <code>csv</code>. It doesn't read data itself: instead, it takes the lines read by something else and turns them into lists of values by splitting on commas:</p>
</div>


<div class="in">
<pre>import csv

data = &#39;&#39;&#39;first,FIRST
second,SECOND
third,THIRD&#39;&#39;&#39;
reader = cStringIO.StringIO(data)
wrapper = csv.reader(reader)
for record in wrapper:
    print record</pre>
</div>

<div class="out">
<pre>[&#39;first&#39;, &#39;FIRST&#39;]
[&#39;second&#39;, &#39;SECOND&#39;]
[&#39;third&#39;, &#39;THIRD&#39;]
</pre>
</div>


<div>
<p>Putting it all together, we can get data for Canada like this:</p>
</div>


<div class="in">
<pre>url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv&#39;
response = requests.get(url)
if response.status_code != 200:
    print &#39;Failed to get data:&#39;, response.status_code
else:
    reader = cStringIO.StringIO(response.text)
    wrapper = csv.reader(reader)
    for record in wrapper:
        year = int(record[0])
        value = float(record[1])
        print year, &#39;:&#39;, value</pre>
</div>

<div class="out">
<pre>---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-10-da21db395042&gt; in &lt;module&gt;()
      7     wrapper = csv.reader(reader)
      8     for record in wrapper:
----&gt; 9         year = int(record[0])
     10         value = float(record[1])
     11         print year, &#39;:&#39;, value

ValueError: invalid literal for int() with base 10: &#39;year&#39;</pre>
</div>


<div>
<p>Whoops. The first line of data returned by the server is:</p>
<pre><code>year,data</code></pre>
<p>and when we try to convert the string <code>'year'</code> to an integer, Python quite rightly complains. The fix is straightforward:</p>
</div>


<div class="in">
<pre>url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv&#39;
response = requests.get(url)
if response.status_code != 200:
    print &#39;Failed to get data:&#39;, response.status_code
else:
    reader = cStringIO.StringIO(response.text)
    wrapper = csv.reader(reader)
    for record in wrapper:
        if record[0] != &#39;year&#39;:
            year = int(record[0])
            value = float(record[1])
            print year, &#39;:&#39;, value</pre>
</div>

<div class="out">
<pre>1901 : -7.6724190712
1902 : -7.8627114296
1903 : -7.91078281403
1904 : -8.15572929382
1905 : -7.547311306
1906 : -7.68410348892
1907 : -8.41355323792
1908 : -7.79092931747
1909 : -8.23930549622
1910 : -7.77461147308
1911 : -8.11444664001
1912 : -7.88540267944
1913 : -7.98794031143
1914 : -7.96593761444
1915 : -7.14403915405
1916 : -8.13297843933
1917 : -8.49991416931
1918 : -8.204662323
1919 : -8.03598594666
1920 : -7.83067989349
1921 : -7.68577718735
1922 : -8.33498954773
1923 : -8.02212524414
1924 : -7.57456827164
1925 : -7.95162582397
1926 : -7.79278945923
1927 : -7.96172714233
1928 : -7.23797512054
1929 : -8.12365150452
1930 : -7.30230569839
1931 : -6.6463394165
1932 : -7.82168865204
1933 : -8.69313430786
1934 : -7.96432733536
1935 : -8.16696739197
1936 : -8.59422492981
1937 : -7.3392534256
1938 : -6.85634899139
1939 : -7.66910791397
1940 : -6.7993812561
1941 : -7.23310470581
1942 : -7.09781265259
1943 : -7.22318792343
1944 : -6.60394668579
1945 : -7.64634561539
1946 : -7.73950958252
1947 : -7.16152429581
1948 : -7.65996932983
1949 : -7.69635295868
1950 : -8.51782989502
1951 : -7.90392971039
1952 : -6.68076992035
1953 : -6.75395202637
1954 : -7.33406448364
1955 : -7.58600091934
1956 : -8.27430534363
1957 : -7.76330089569
1958 : -6.90325784683
1959 : -7.87138366699
1960 : -6.95103311539
1961 : -7.94641208649
1962 : -7.46536016464
1963 : -7.36332845688
1964 : -8.24113082886
1965 : -8.0782699585
1966 : -7.83267879486
1967 : -7.97359228134
1968 : -7.36812067032
1969 : -7.03929138184
1970 : -7.72057342529
1971 : -7.46978092194
1972 : -9.52518749237
1973 : -6.85334157944
1974 : -8.42878723145
1975 : -7.62185668945
1976 : -7.58889532089
1977 : -6.55725765228
1978 : -7.99333572388
1979 : -7.84571743011
1980 : -7.04917144775
1981 : -5.5066652298
1982 : -8.51379394531
1983 : -7.46353626251
1984 : -7.41419839859
1985 : -7.4329161644
1986 : -7.7103509903
1987 : -6.45378351212
1988 : -6.61003017426
1989 : -7.70648574829
1990 : -7.67799854279
1991 : -7.09514713287
1992 : -7.69788742065
1993 : -6.98641967773
1994 : -6.88878011703
1995 : -6.85032272339
1996 : -7.33745718002
1997 : -6.88342809677
1998 : -5.18619298935
1999 : -5.9755191803
2000 : -6.72654485703
2001 : -5.93072795868
2002 : -6.85216426849
2003 : -6.402592659
2004 : -7.52971744537
2005 : -5.863758564
2006 : -5.54320955276
2007 : -6.81929397583
2008 : -7.20089578629
2009 : -6.99701166153
</pre>
</div>


<div class="challenges">
<h4 id="challenges">Challenges</h4>
<ol style="list-style-type: decimal">
<li>FIXME</li>
</ol>
</div>


<div class="keypoints">
<h4 id="key-points">Key Points</h4>
<ul>
<li>FIXME</li>
</ul>
</div>
