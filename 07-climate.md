---
layout: lesson
root: ../..
title: "Worked Example: Climate Data"
level: novice
---
To pull everything together,
we'll analyze some climate data to find out
whether some parts of the world are getting hotter and drier faster than others.

### Step 1: Finding the Data

A growing number of organizations make data sets available on the web.
For this example,
we'll use data generated by 15 global circulation models (GCMs)
and provided through the World Bank's
[Climate Data API](http://data.worldbank.org/developers/climate-data-api).
As that page says,
the data sets containing yearly averages for various values
are identified by URLs of the form:

http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/<em>var</em>/year/<em>ISO3</em>.<em>ext</em>

where:

*   <em>var</em> is either "pr" (for precipitation) or "tas" (for "temperature at surface");
*   <em>ISO3</em> is the International Standards Organization (ISO) 3-letter code for a specific country,
    such as "CAN" for Canada;
    and
*   <em>ext</em> (short for "extension") identifies the format we want the data in,
    such as "csv" (for comma-separated values)
    or "xml" (for XML).

For example,
if we want the average annual temperature in Canada
as a CSV file,
the URL is:

http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv

If you copy and paste that URL into a browser,
it displays:

<div class="file" markdown="1">
~~~
year,data
1901,-7.67241907119751
1902,-7.862711429595947
1903,-7.910782814025879
...
2007,-6.819293975830078
2008,-7.2008957862854
2009,-6.997011661529541
~~~
</div>

### Step 2: Getting the Data

If we only wanted to look at data for two or three countries,
we could just download those files one by one.
But we want to compare data for many different pairs of countries,
which means we should write a program.

Python has a library called `urllib2` for working with URLs.
It can be clumsy to use,
though,
so many people (including us) prefer a third-party library
called [Requests](http://docs.python-requests.org/en/latest/).
To install it,
simply run the command:

<div class="in" markdown="1">
~~~
$ pip install requests
~~~
</div>

Getting the data we want is then as simple as this:

<div class="file" markdown="1">
~~~
import requests

url = 'http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv'
response = requests.get(url)
if response.status_code != 200:
    print 'Failed to get data:', response.status_code
else:
    print response.text
~~~
</div>

The first line imports the `requests` library.
We then define the URL for the data we want
and ask the library to get it.
`requests` creates an object to store the response and returns it to us.
We check that its status code is 200
(meaning "everything is OK"),
and if it is,
print the text of the reply.

### Step 3: Parsing the Data

Our little program gets the data we want,
but returns it as one long character string
rather than as a list of numbers.
There are two ways we could convert the former to the latter:

1.  Write a function to split that string on newline characters to create lines,
    then split the lines on commas
    and convert the second part of each to a number.
2.  Use a couple of Python libraries to do this for us.

Most experienced programmers would say that the second approach is better,
but that's only true if we know that libraries exist to do the things we want.
In fact,
even that isn't true:
the "use the library" approach is only more effective
if we know enough about the standard libraries
to think about our problem in terms of the capabilities they provide.

Let's give both methods a try.
Here's a small program to test the first approach:

<div class="file" markdown="1">
~~~
input_data = '1901,12.3\n1902,45.6\n1903,78.9\n'
print 'input data is:'
print input_data

as_lines = input_data.split('\n')
print 'as lines:'
print as_lines

for line in as_lines:
    fields = line.split(',')
    year = int(fields[0])
    value = float(fields[1])
    print year, ':', value
~~~
</div>

Its output is:
<div class="out" markdown="1">
~~~
input data is:
1901,12.3
1902,45.6
1903,78.9

as lines:
['1901,12.3', '1902,45.6', '1903,78.9', '']
1901 : 12.3
1902 : 45.6
1903 : 78.9
~~~
</div>
<div class="err" markdown="1">
~~~
Traceback (most recent call last):
  File "parse-manually.py", line 11, in <module>
    year = int(fields[0])
ValueError: invalid literal for int() with base 10: ''
~~~
</div>

That's close to what we want, but not perfect.
The error occurs because there's a newline at the end of our test data,
so `str.split` puts an empty string as the last element of `as_lines`,
which we obviously can't split on commas.

We could fix this,
but instead let's try using a couple of standard libraries.
The first one,
called `cStringIO`,
allows Python to treat a string in memory as if it were a file on disk:

<div class="in" markdown="1">
~~~
import cStringIO

data = 'first\nsecond\nthird\n'
reader = cStringIO.StringIO(data)
for line in reader:
    print line
~~~
</div>
<div class="out" markdown="1">
~~~
first

second

third

~~~
</div>

Here,
`reader` is an object that behaves like a file,
but reads characters from a string instead of from a file.
As we'll see in the exercises,
we can also write to a `StringIO` object,
which is very useful when we're testing programs.

The second library we'll use is called `csv`.
It doesn't read data itself:
instead,
it transforms the data something else is reading into lists of values:

<div class="in" markdown="1">
~~~
import cStringIO
import csv

data = 'first\nsecond\nthird\n'
reader = cStringIO.StringIO(data)
wrapper = csv.reader(reader)
for record in wrapper:
    print record
~~~
</div>
<div class="out" markdown="1">
~~~
['first']
['second']
['third']
~~~
</div>

Here's a more interesting example:

<div class="in" markdown="1">
~~~
import cStringIO
import csv

data = '1901,12.3\n1902,45.6\n1903,78.9\n'
reader = cStringIO.StringIO(data)
wrapper = csv.reader(reader)
for record in wrapper:
    print record
~~~
</div>
<div class="out" markdown="1">
~~~
['1901', '12.3']
['1902', '45.6']
['1903', '78.9']
~~~
</div>

Putting it all together,
we can get data for Canada like this:

<div class="in" markdown="1">
~~~
import requests
import cStringIO
import csv

url = 'http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv'
response = requests.get(url)
if response.status_code != 200:
    print 'Failed to get data:', response.status_code
else:
    reader = cStringIO.StringIO(response.text)
    wrapper = csv.reader(reader)
    for record in wrapper:
        year = int(record[0])
        value = float(record[1])
        print year, ':', value
~~~
</div>

But when we run this program,
we get:

<div class="err" markdown="1">
~~~
Traceback (most recent call last):
  File "get-parse-data.py", line 13, in <module>
    year = int(record[0])
ValueError: invalid literal for int() with base 10: 'year'
~~~
</div>

The problem is that the first row is a title:

~~~
year,data
~~~

Here's the change:

<div class="in" markdown="1">
~~~
    reader = cStringIO.StringIO(response.text)
    wrapper = csv.reader(reader)
    for record in wrapper:
        if record[0] != 'year':
            year = int(record[0])
            value = float(record[1])
            print year, ':', value
~~~
</div>

And here's its output:

<div class="out" markdown="1">
~~~
1901 : -7.6724190712
1902 : -7.8627114296
1903 : -7.91078281403
...
2007 : -6.81929397583
2008 : -7.20089578629
2009 : -6.99701166153
~~~
</div>

### Step 4: Making a Reusable Function

Let's put our code in a function:

<div class="in" markdown="1">
~~~
def get_country_temperatures(country):
    '''
    Get average surface temperature by country from the World Bank.
    Result is [ [year, value], [year, value], ...].
    '''

    base_url = 'http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/{0}.csv'
    actual_url = base_url.format(country)
    response = requests.get(actual_url)
    reader = cStringIO.StringIO(response.text)
    wrapper = csv.reader(reader)
    result = []
    for record in wrapper:
        if record[0] != 'year':
            year = int(record[0])
            value = float(record[1])
            result.append([year, value])
    return result
~~~
</div>

and then write and run a couple of tests:

<div class="in" markdown="1">
~~~
def test_nonexistent_country():
    values = get_country_temperatures('XYZ')
    assert len(values) == 0, 'Should not have succeeded for country XYZ'

def test_canada():
    values = get_country_temperatures('CAN')
    assert len(values) > 0, 'Should have had data for country CAN'

def run_tests():
    test_nonexistent_country()
    test_canada()
    print 'all tests passed'

run_tests()
~~~
</div>
<div class="out" markdown="1">
~~~
all tests passed
~~~
</div>

### Step 5: Comparing Countries

Before we do the comparison we started out to do,
let's look at two more useful tools Python gives us.
The first is the `zip` function,
which combines corresponding pairs of elements from two lists:

<div class="in" markdown="1">
~~~
lows = [1, 2, 3]
highs = [40, 50, 60]
for thing in zip(lows, highs):
    print thing
~~~
</div>
<div class="out" markdown="1">
~~~
(1, 40)
(2, 50)
(3, 60)
~~~
</div>

The second is the fact that if the things in a list have parts,
we can assign those parts to separate variables in the header of our `for` loop:

<div class="in" markdown="1">
~~~
pairs = [ [1, 10], [2, 20], [3, 30] ]
for (left, right) in pairs:
    print 'left:', left, 'and right:', right
~~~
</div>
<div class="out" markdown="1">
~~~
left: 1 and right: 10
left: 2 and right: 20
left: 3 and right: 30
~~~
</div>

Putting these two ideas together,
we can extract corresponding years and values from
the lists returned by `get_country_temperatures`
like this:

<div class="in" markdown="1">
~~~
canada = [ [1901, -1.0], [1902, -2.0], [1903, -3.0] ]
brazil = [ [1901, 20.0], [1902, 20.0], [1903, 30.0] ]
for ( (left_year, left_value), (right_year, right_value) ) in zip(canada, brazil):
    print 'years are:', left_year, right_year, 'and values are:', left_value, right_value
~~~
</div>
<div class="out" markdown="1">
~~~
years are: 1901 1901 and values are: -1.0 20.0
years are: 1902 1902 and values are: -2.0 20.0
years are: 1903 1903 and values are: -3.0 30.0
~~~
</div>

This means our comparison function is:

<div class="in" markdown="1">
~~~
def compare_countries(left_country, right_country):
    '''
    Compare average surface temperatures for two countries over time.
    '''
    left_data = get_country_temperatures(left_country)
    right_data = get_country_temperatures(right_country)
    result = []
    for ( (left_year, left_value), (right_year, right_value) ) in zip(canada, brazil):
        assert left_year == right_year, 'Year mismatch: {0} vs {1}'.format(left_year, right_year)
        result.append([left_year, left_value - right_value])
    return result
~~~
</div>

Note that this function doesn't print the comparison:
we might want to do that when debugging,
but in a real analysis,
we'll want to send the temperature differences to a statistics package
or plot them.
